namespace Spritey.ImageProcessing.Sprites
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using Spritey.ImageProcessing.CompositeMapping;

    /// <summary>
    /// Represents the contents of a sprite image.
    /// </summary>
    public class SpriteBlueprint : ISpriteBlueprint
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SpriteBlueprint"/> class.
        /// </summary>
        public SpriteBlueprint()
        {
            this.MappedImages = new List<IMappedImageInfo>();
            this.Width = 0;
            this.Height = 0;
        }

        /// <summary>
        /// Gets holds the locations of all the individual images within the sprite image.
        /// </summary>
        public List<IMappedImageInfo> MappedImages { get; } = null;

        /// <summary>
        /// Gets width of the sprite image in pixels
        /// </summary>
        public int Width { get; private set; } = 0;

        /// <summary>
        /// Gets height of the sprite image in pixels
        /// </summary>
        public int Height { get; private set; } = 0;

        /// <summary>
        /// Gets area of the sprite image
        /// </summary>
        public int Area
        {
            get { return this.Width * this.Height; }
        }

        /// <summary>
        /// Takes a directory of images and generates a Sprite blueprint which contains the optimal
        /// X/Y coordinates of each image within a larger composite image (a Sprite).
        /// </summary>
        /// <param name="sImageDirectoryPath">
        /// The directory that contains the images.
        /// The name of each image in the directory will be the name of the corresponding CSS
        /// class generated by SpriteGenerator.GetSpriteCSS().
        /// </param>
        /// <param name="layout">
        /// Either <see cref="Orientation.HorizontalOnly"/>, <see cref="Orientation.VerticalOnly"/>, or<see cref="Orientation.Optimal"/>
        /// </param>
        /// <returns>
        /// A SpriteBlueprint object which contains the optimal X/Y coordinates of each image
        /// within a larger composite image (a Sprite).
        /// </returns>
        /// <remarks>
        /// Animated images will be skipped. These images will be missing from the blueprint.
        /// </remarks>
        public static ISpriteBlueprint GetFromImageDirectory(string sImageDirectoryPath, Orientation layout = Orientation.Optimal)
        {
            if (Directory.Exists(sImageDirectoryPath))
            {
                var imgInfo = ImageInfo.GetStaticFromImageDirectory(sImageDirectoryPath).OrderBy((img) => img.Name).ToList();

                // The program will also stop trying when it finds a candidate with efficiency greater or equal to
                // <Cutoff efficiency>. Efficiency is <total area all rectangles> / <area enclosing rectangle> -
                // so a perfect solution has efficiency 1.0 and worse solutions have lower efficiencies. You may want to start experimenting with
                // cutoff efficiencies between 0.8 and 0.9. To have the program try to achieve the best efficiency without cutoff, set this to 1.0.
                float cutoffEfficiency = 1.0F;

                // The program will stop trying to get a better solution after it has generated <Maximum number successful candidates>
                // successful candidates (that is, solutions for packing all rectangles in the enclosing rectangle). Often after 1 or 2
                // solutions have been generated, you are unlikely to get a much better one. Set <Maximum number successful candidates>
                // to a high number to take away this limit.
                int maximumNbrCandidates = 100; // TODO: This value could probably be lower...

                IMapper<SpriteBlueprint> mapper = null;
                switch (layout)
                {
                    case Orientation.HorizontalOnly:
                        mapper = new MapperHorizontalOnly<SpriteBlueprint>();
                        break;
                    case Orientation.VerticalOnly:
                        mapper = new MapperVerticalOnly<SpriteBlueprint>();
                        break;
                    case Orientation.Optimal:
                    default:
                        mapper = new MapperOptimalEfficiency<SpriteBlueprint>(new Canvas(), cutoffEfficiency, maximumNbrCandidates);
                        break;
                }

                return imgInfo.Count > 0 ? mapper.Mapping(imgInfo) : null;
            }
            else
            {
                throw new Exception("The directory \"" + sImageDirectoryPath + "\" does not exist");
            }
        }

        /// <summary>
        /// Adds a Rectangle to the SpriteInfo, and updates the width and height of the SpriteInfo.
        /// </summary>
        /// <param name="imageLocation">The image to add</param>
        public void AddMappedImage(IMappedImageInfo imageLocation)
        {
            this.MappedImages.Add(imageLocation);

            IImageInfo newImage = imageLocation.ImageInfo;

            int highestY = imageLocation.Y + newImage.Height;
            int rightMostX = imageLocation.X + newImage.Width;

            if (this.Height < highestY)
            {
                this.Height = highestY;
            }

            if (this.Width < rightMostX)
            {
                this.Width = rightMostX;
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            foreach (IMappedImageInfo minfo in this.MappedImages)
            {
                ((ImageInfo)minfo.ImageInfo).Dispose();
            }
        }
    }
}